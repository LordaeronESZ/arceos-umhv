# 远程 CI 运行

## 0. 为什么需要远程 CI

> 和直觉不同，此处“本地”指 GitHub 服务器，而“远程”指在我们所使用的，相对于 GitHub 服务器而言是“远程”的服务器。

需要远程 CI 的原因有很多，最主要的，也是本次工作最直接的原因是：GitHub Actions 所使用的硬件是我们完全无法控制的。在大部分情况下，这并不是一个问题；然而在 Hypervisor 开发过程中，Intel 和 AMD 的 CPU 采用了不同的虚拟化技术；由于目前我们只实现了 Intel 的虚拟化技术，因此在 GitHub Actions 所运行的 AMD CPU 上无法运行 Hypervisor；即使未来我们实现了 AMD 的虚拟化技术，也无法在 GitHub Actions 的硬件同时测试两种虚拟化技术。

除此之外，远程 CI 还有很多其他的优点，例如：

- 更充足的硬件资源
- 更详细的日志信息
- 当遇到硬件环境相关的问题时，可以更方便地调试
- 更加丰富的操作，例如自动测试有依赖关系的crate
- 避免 QEMU 和 musl 环境反复构建

## 1. 通过 GitHub Actions 运行远程 CI

目前我们采用了最简单的方式来运行远程 CI：通过 GitHub Actions 启动一个 SSH 连接，然后在远程服务器上运行 CI 测试。在远程服务器上运行测试所需的所有环境都已经配置好，所有文件（包括代码和测试所需的镜像）则都由 GitHub Actions 打包并上传到远程服务器。

采取这种方式的原因是：

- 在本地和远程服务器上运行 CI 测试所需的命令是几乎一致的；
- 这些命令，在 GitHub Actions 上，是记录在 `.github/workflows` 目录下的配置文件中的；
- 而这些配置文件不能直接在远程服务器上运行；存在一些工具，例如 `act`，但是受限于各种网络环境问题，无法真正使用；
- 将这些文件改写成 shell 脚本，则确实可以在远程服务器上运行，但是这样会导致配置文件的维护困难，因此不是一个好的选择；
- 因此，最好的方式是，将绝大多数工作都交给 GitHub Actions，而只将真正需要在远程服务器上运行的部分（实际运行）交给远程服务器。

实现细节参见[这个文件](./test.yml)
